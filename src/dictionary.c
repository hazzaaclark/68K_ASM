/* COPYRIGHT (C) HARRY CLARK 2024 */

/* MOTOROLA 68000 ASSEMBLER */

/* THIS FILE FOCUSES ON THE DICTIONARY ENTRIES PERTAINING TO IDENTIFIERS */
/* AND DIRECTIVES IN RELATION TO 68K ASSEMBLY */

#include "dictionary.h"

#undef USE_DICTIONARY

/* INITIALISE THE DICTIONARY HASH TABLE ENTRY SET */
/* DETERMINE THE ALLOCATABLE SIZE OF RESPECTIVE HASH TABLE ENTRIES */

/* CREATED A TREE SYSTEM TO STORE THE CORRESPONDING IDENTIFIER */
/* IN RELATION TO WHICH SEMANTIC IS BEING PARSED */

bool DICTIONARY_INIT(struct DICTIONARY_ENTRY* ENTRY)
{
    ENTRY->ENTRY_SUCCESS = true;
    ENTRY->HASH_CASES = 0;

    /* FIRST DETERMINE THE ALLOCATABLE SPACE FOR THE HASH TABLE */
    /* TO STORE ALL PRE-REQUISITES */

    ENTRY->HASH_TABLE = malloc(DICT_HASH_TABLE_ENTRIES * sizeof(ENTRY->HASH_TABLE));

    if (ENTRY->HASH_TABLE == NULL) 
    {
        ENTRY->ENTRY_SUCCESS = false;
        return false;
    }

    /* ALLOCATE THAT CORRESPONDING SPACE INTO THE RESPECTIVE ENTRY */
    /* THIS IS BY CASTING A POINTER TO DETERMINE THE OFFSET OF THE SYMBOL */
    /* BASED ON HASH TABLE ENTRIES */

    memset(ENTRY->HASH_TABLE, 0, sizeof(ENTRY->HASH_TABLE) * DICT_HASH_TABLE_ENTRIES);
    return ENTRY->ENTRY_SUCCESS;
}

void DICTIONARY_FREE(void)
{
    struct DICTIONARY_ENTRY* ENTRY;

    /* FOR EVERY ADDRESSABLE HASH TABLE INDENTATION IN RELATION TO THE MAX AMOUNT */
    /* DETERMINE IF THE TABLE IS STILL BEING USED, OTHERWISE, FREE THE STACK */

    for (int i = 0; i < DICT_HASH_TABLE_ENTRIES; i++) 
    {
        ENTRY = ENTRY->HASH_TABLE;
        while (ENTRY != NULL) 
        {
            struct DICTIONARY_ENTRY* next = ENTRY->NEXT;
            free(ENTRY);
            ENTRY = next;
        }
    }

    free(ENTRY->HASH_TABLE);
}

/* CREATE AN INITIAL ENTRY FOR THE SYMBOL BY WHICH THE LOOKUP TABLE IS TRYING TO ACCESS */
/* IN DOING SO, CREATE ALLOCATABLE SPACE WITHIN THE HASH TABLE FOR THE NEW ENTRY */

void DICTIONARY_CREATE_DIRECTIVE(struct DICTIONARY_ENTRY* ENTRY, const char* IDENTIFIER __attribute__((unused)), UNK IDENTIFIER_LENGTH __attribute__((unused)))
{
    /* ASSUME THAT AN ARBITRARY SEARCH VALUE DICTATES THE STATUS OF THE DIRECTIVE */
    /* IF THE SEARCH RESULT FINDS A CORRESPONDING DIRECTIVE, THE OFFSET POINTER WILL READ THIS */

    UINT* SEARCH_RESULT = NULL; 

    /* IF THE SEARCH RESULT FINDS THE DIRECTIVE */
    /* SET THE READER TO THE ADDRESS OF THE PARENT OF THE NODE TREE */

    if (*SEARCH_RESULT == DICT_SEARCH_FOUND) 
    {
        return;
    }

    /* OTHERWISE, CREATE THE MISSING NODES REQUIRED FOR THE SYMBOL */
    else 
    {
        DICTIONARY_ENTRY* NEW_ENTRY = (DICTIONARY_ENTRY*)malloc(sizeof(DICTIONARY_ENTRY) - 1 + IDENTIFIER_LENGTH);

        if (NEW_ENTRY == NULL)
            ENTRY->ENTRY_SUCCESS = false;
        else 
        {
            NEW_ENTRY->PARENT = NULL;
            NEW_ENTRY->LEFT = NULL;
            NEW_ENTRY->RIGHT = NULL;

            NEW_ENTRY->NEXT = NULL;
            NEW_ENTRY->PREVIOUS = NULL;
            NEW_ENTRY->TYPE = -1;

            NEW_ENTRY->IDENTIFIER_LENGTH = IDENTIFIER_LENGTH;

            if (ENTRY->OFFSET != NULL)
                return;
        }
    }
}

/* NOW WE CAN ACTUALLY BEGIN TO ADD CORRESPONDING ENTRIES TO THE HASH TABLE */
/* THIS IS BY ASSUMING THE APPROPRIATE IDENTIFIER LENGTH AND ADDING THE EVALUATION TO THE DICTIONARY */

DICTIONARY_ENTRY* DICTIONARY_LOOKUP(struct FILE_SEMANTIC* FILE_STATE, const char* IDENTIFIER, UNK IDENTIFIER_LENGTH)
{
    /* FIRST DETERMINE IF THE CORRESPONDING SYMBOL IS WHAT WE ARE LOOKING FOR IN ACCORDANCE WITH ITS LENGTH */

    char* EXPECTED = (char*)DICTIONARY_IDENTIFIER(FILE_STATE, IDENTIFIER, IDENTIFIER_LENGTH);
    UNK EXPECTED_LENGTH = 0;

    /* IF IT DOES EXIST, EVALUATE ITS LENGTH AND ACCOMMODATE FOR A NEW ENTRY */

    if (EXPECTED != NULL) 
    {
        IDENTIFIER = EXPECTED;
        IDENTIFIER_LENGTH = EXPECTED_LENGTH;
    }

    DICTIONARY_ENTRY* ENTRY_LOOKUP = (DICTIONARY_ENTRY*)malloc(sizeof(DICTIONARY_ENTRY) + (*IDENTIFIER) * IDENTIFIER_LENGTH);

    if (ENTRY_LOOKUP != NULL) 
    {
        /* ASSUMING DICT_SEARCH_FOUND IS A MACRO OR A DEFINED VALUE USED FOR COMP */

        if (ENTRY_LOOKUP == DICT_SEARCH_FOUND)
            ENTRY_LOOKUP = NULL;
        else
            ENTRY_LOOKUP += sizeof(ENTRY_LOOKUP->PARENT);
    }

    free(EXPECTED);
    return ENTRY_LOOKUP;
}

/* REMOVE ANY AND ALL UNWANTED ENTRIES FROM THE HASH TABLE */

bool DICTIONARY_REMOVE(struct DICTIONARY_ENTRY* ENTRY)
{
    ENTRY->ENTRY_SUCCESS = true;

    if (ENTRY->HASH_TABLE != DICT_SEARCH_FOUND)
        ENTRY->ENTRY_SUCCESS = false;
    else
        free(ENTRY);

    return ENTRY->ENTRY_SUCCESS;
}
